# RSA暗号

## 目次
1. [数学的基礎](#数学的基礎)
2. [RSA暗号の概要](#rsa暗号の概要)
3. [RSA暗号の正当性証明](#rsa暗号の正当性証明)
4. [RSA暗号の安全性](#rsa暗号の安全性)
5. [RSA-OAEP](#rsa-oaep)

## 数学的基礎

### 剰余環

**定義**: 整数 \(n > 1\) に対して、剰余環 \(\mathbb{Z}_n\) は以下のように定義される：

\[\mathbb{Z}_n = \{0, 1, 2, \ldots, n-1\}\]

この集合上で加法と乗法を以下のように定義する：

- 加法: \(a + b \pmod{n}\)
- 乗法: \(a \cdot b \pmod{n}\)

**性質**:
- \(\mathbb{Z}_n\) は可換環である
- 零元は \(0\)、単位元は \(1\)
- 一般に、\(\mathbb{Z}_n\) は整域ではない（\(n\) が合成数の場合）

### イデアル

**定義**: 環 \(R\) の部分集合 \(I\) がイデアルであるとは、以下を満たすこと：

1. \(I\) は加法について部分群
2. 任意の \(r \in R\) と \(i \in I\) に対して \(r \cdot i \in I\)

**例**: \(\mathbb{Z}_n\) において、\(d \mid n\) なる \(d\) に対して、\(\{0, d, 2d, \ldots, n-d\}\) はイデアルである。

### オイラーのトーシェント関数

**定義**: 正整数 \(n\) に対して、オイラーのトーシェント関数 \(\phi(n)\) は以下のように定義される：

\[\phi(n) = |\{a \in \{1, 2, \ldots, n\} \mid \gcd(a, n) = 1\}|\]

すなわち、\(n\) 以下で \(n\) と互いに素な正整数の個数である。

**性質**:
- 素数 \(p\) に対して \(\phi(p) = p-1\)
- 互いに素な正整数 \(m, n\) に対して \(\phi(mn) = \phi(m)\phi(n)\)（乗法的性質）
- 素数 \(p\) と正整数 \(k\) に対して \(\phi(p^k) = p^k - p^{k-1} = p^k(1-1/p)\)
- 一般に、\(n = p_1^{e_1} p_2^{e_2} \cdots p_k^{e_k}\) の素因数分解に対して：
  \[\phi(n) = n \prod_{i=1}^k \left(1 - \frac{1}{p_i}\right)\]

### ラグランジュの定理

**定理**: 有限群 \(G\) の任意の部分群 \(H\) の位数は、\(G\) の位数の約数である。

**証明**: 部分群 \(H\) による左剰余類を考える。任意の \(g \in G\) に対して、剰余類 \(gH = \{gh \mid h \in H\}\) を定義する。

1. 任意の2つの剰余類 \(g_1H, g_2H\) は、\(g_1H \cap g_2H \neq \emptyset\) ならば \(g_1H = g_2H\) である
2. 各剰余類の要素数は \(|H|\) に等しい
3. \(G\) は互いに素な剰余類の和集合として表される

したがって、\(|G| = k|H|\) なる正整数 \(k\) が存在し、\(|H|\) は \(|G|\) の約数である。\(\square\)

**系**: 有限群 \(G\) の任意の元 \(g\) の位数は、\(G\) の位数の約数である。

**証明**: 元 \(g\) が生成する巡回部分群 \(\langle g \rangle\) の位数は \(g\) の位数に等しい。ラグランジュの定理より、これは \(|G|\) の約数である。\(\square\)

### 乗法群

**定義**: 剰余環 \(\mathbb{Z}_n\) の乗法群 \(\mathbb{Z}_n^*\) は以下のように定義される：

\[\mathbb{Z}_n^* = \{a \in \mathbb{Z}_n \mid \gcd(a, n) = 1\}\]

**性質**:
- \(\mathbb{Z}_n^*\) は乗法について群をなす
- 位数は \(\phi(n)\)（オイラーのトーシェント関数）

### 位数

**定義**: 群 \(G\) の元 \(g\) の位数は、\(g^k = 1\) となる最小の正整数 \(k\) である。

**性質**:
- 有限群の任意の元の位数は群の位数の約数
- \(\mathbb{Z}_n^*\) において、元 \(a\) の位数は \(a^{\text{ord}(a)} \equiv 1 \pmod{n}\) を満たす最小の正整数

### 中国剰余定理（CRT）

**定理**: 互いに素な整数 \(n_1, n_2, \ldots, n_k\) に対して、連立合同式

\[x \equiv a_1 \pmod{n_1}\]
\[x \equiv a_2 \pmod{n_2}\]
\[\vdots\]
\[x \equiv a_k \pmod{n_k}\]

は一意な解 \(x \pmod{N}\) を持つ。ここで \(N = n_1 \cdot n_2 \cdots n_k\) である。

**証明**: 存在性と一意性を別々に示す。

**存在性**: \(N_i = N/n_i\) とおく。\(\gcd(n_i, N_i) = 1\) より、\(N_i\) の逆元 \(M_i\) が存在する（\(N_i \cdot M_i \equiv 1 \pmod{n_i}\)）。

解は以下で与えられる：

\[x = a_1 \cdot N_1 \cdot M_1 + a_2 \cdot N_2 \cdot M_2 + \cdots + a_k \cdot N_k \cdot M_k\]

**一意性**: \(x, y\) が両方とも解であるとすると、\(x \equiv y \pmod{n_i}\) が全ての \(i\) について成り立つ。\(n_i\) が互いに素であることから、\(x \equiv y \pmod{N}\) が従う。

### オイラーの定理

**定理**: \(\gcd(a, n) = 1\) なる整数 \(a, n\) に対して、

\[a^{\phi(n)} \equiv 1 \pmod{n}\]

が成り立つ。ここで \(\phi(n)\) はオイラーのトーシェント関数である。

**証明**: \(\mathbb{Z}_n^*\) の位数が \(\phi(n)\) であることから、ラグランジュの定理により任意の元 \(a\) の位数は \(\phi(n)\) の約数である。したがって、\(a^{\phi(n)} \equiv 1 \pmod{n}\) が成り立つ。

### フェルマーの小定理

**定理**: 素数 \(p\) と、\(p\) と互いに素な整数 \(a\) に対して、

\[a^{p-1} \equiv 1 \pmod{p}\]

が成り立つ。

**証明**: 素数 \(p\) に対して \(\phi(p) = p-1\) であることから、オイラーの定理の特殊場合である。

## RSA暗号の概要

### 基本的なRSA暗号

RSA暗号は、1977年にRivest、Shamir、Adlemanによって提案された公開鍵暗号方式である。

**鍵生成**:
1. 大きな素数 \(p, q\) を選ぶ
2. \(n = p \cdot q\) を計算
3. \(\phi(n) = (p-1)(q-1)\) を計算
4. \(\gcd(e, \phi(n)) = 1\) なる整数 \(e\) を選ぶ
5. \(d \cdot e \equiv 1 \pmod{\phi(n)}\) なる整数 \(d\) を計算

- 公開鍵: \((n, e)\)
- 秘密鍵: \((n, d)\)

**暗号化**: 平文 \(m \in \mathbb{Z}_n\) に対して、

\[c = m^e \pmod{n}\]

**復号化**: 暗号文 \(c\) に対して、

\[m = c^d \pmod{n}\]

### 数学的根拠

RSA暗号の正当性は、オイラーの定理に基づいている。

**補題**: \(ed \equiv 1 \pmod{\phi(n)}\) のとき、任意の \(m \in \mathbb{Z}_n\) に対して

\[(m^e)^d \equiv m \pmod{n}\]

が成り立つ。

**証明**: \(ed = 1 + k\phi(n)\) なる整数 \(k\) が存在する。

**場合1**: \(\gcd(m, n) = 1\) の場合
オイラーの定理より \(m^{\phi(n)} \equiv 1 \pmod{n}\) であるから、

\[(m^e)^d = m^{ed} = m^{1 + k\phi(n)} = m \cdot (m^{\phi(n)})^k \equiv m \cdot 1^k = m \pmod{n}\]

**場合2**: \(\gcd(m, n) \neq 1\) の場合
\(\gcd(m, n) \neq 1\) かつ \(m < n\) より、\(m\) は \(p\) または \(q\) の倍数である。一般性を失わず \(m\) は \(p\) の倍数とする。

このとき、\(m \equiv 0 \pmod{p}\) より \((m^e)^d \equiv 0 \equiv m \pmod{p}\)

また、\(\gcd(m, q) = 1\) より、フェルマーの小定理から \(m^{q-1} \equiv 1 \pmod{q}\) である。したがって、

\[(m^e)^d = m^{ed} = m^{1 + k\phi(n)} = m \cdot (m^{q-1})^{k(p-1)} \equiv m \cdot 1^{k(p-1)} = m \pmod{q}\]

中国剰余定理より、\((m^e)^d \equiv m \pmod{n}\) が従う。

## RSA暗号の正当性証明

### 形式的な正当性証明

**定理**: RSA暗号方式は正当性を満たす。すなわち、任意の平文 \(m \in \mathbb{Z}_n\) に対して、

\[\mathsf{Dec}(\mathsf{sk}, \mathsf{Enc}(\mathsf{pk}, m)) = m\]

が成り立つ。

**証明**: 鍵生成で \(ed \equiv 1 \pmod{\phi(n)}\) が保証されている。上記の補題により、

\[\mathsf{Dec}(\mathsf{sk}, \mathsf{Enc}(\mathsf{pk}, m)) = (m^e)^d \pmod{n} = m\]

が成り立つ。\(\square\)



## 高速なRSA暗号アルゴリズム

### べき乗算アルゴリズム

RSA暗号の核心は、大きな数のべき乗算 \(a^k \bmod n\) の効率的な計算である。以下に主要なアルゴリズムを紹介する。

#### Left-to-Right Binary Method（左から右バイナリ法）

**アルゴリズム**:
```
Input: a, k, n
Output: a^k mod n

1. result = 1
2. for i from (bit_length(k) - 1) down to 0:
3.     result = (result * result) mod n
4.     if k[i] == 1:
5.         result = (result * a) mod n
6. return result
```

**例**: \(a^{13} \bmod n\) の計算
- \(13 = (1101)_2\)
- 初期値: \(result = 1\)
- \(i=3\): \(result = 1^2 = 1\), \(k[3]=1\) より \(result = 1 \cdot a = a\)
- \(i=2\): \(result = a^2\), \(k[2]=1\) より \(result = a^2 \cdot a = a^3\)
- \(i=1\): \(result = (a^3)^2 = a^6\), \(k[1]=0\) より変化なし
- \(i=0\): \(result = (a^6)^2 = a^{12}\), \(k[0]=1\) より \(result = a^{12} \cdot a = a^{13}\)

**計算量**: \(O(\log k)\) 回の乗算

#### Right-to-Left Binary Method（右から左バイナリ法）

**アルゴリズム**:
```
Input: a, k, n
Output: a^k mod n

1. result = 1
2. base = a
3. for i from 0 to (bit_length(k) - 1):
4.     if k[i] == 1:
5.         result = (result * base) mod n
6.     base = (base * base) mod n
7. return result
```

**特徴**: Left-to-Right法と同様の計算量だが、並列化しやすい構造を持つ。

#### Montgomery乗算

**目的**: 剰余乗算を高速化する手法

**原理**: \(a \cdot b \bmod n\) の計算を、\(a \cdot b \cdot R^{-1} \bmod n\) の形に変換する。ここで \(R\) は \(n\) より大きく、\(R\) と \(n\) が互いに素な数である。

**利点**: 除算を避けて剰余計算を高速化できる。

### Euclid互除法および拡張Euclid互除法

#### 基本的なEuclid互除法

**目的**: 2つの整数の最大公約数を求める

**アルゴリズム**:
```
Input: a, b
Output: gcd(a, b)

1. while b != 0:
2.     r = a mod b
3.     a = b
4.     b = r
5. return a
```

**計算量**: \(O(\log \min(a, b))\)

#### 拡張Euclid互除法

**目的**: \(ax + by = \gcd(a, b)\) を満たす整数 \(x, y\) を求める

**アルゴリズム**:
```
Input: a, b
Output: (gcd(a, b), x, y)

1. if b == 0:
2.     return (a, 1, 0)
3. else:
4.     (d, x', y') = extended_gcd(b, a mod b)
5.     x = y'
6.     y = x' - (a // b) * y'
7.     return (d, x, y)
```

**応用**: RSA暗号における秘密鍵 \(d\) の計算
- \(ed \equiv 1 \pmod{\phi(n)}\) を解くために使用
- 拡張Euclid互除法で \(ed + k\phi(n) = 1\) なる \(d, k\) を求める

### 剰余環における基本演算の計算量

以下に、剰余環 \(\mathbb{Z}_n\) における各種演算の計算量を示す。

| 演算       | アルゴリズム       | 計算量                    | 備考               |
| ---------- | ------------------ | ------------------------- | ------------------ |
| 加算       | 通常の加算 + 剰余  | \(O(\log n)\)             | 1回の除算          |
| 減算       | 通常の減算 + 剰余  | \(O(\log n)\)             | 1回の除算          |
| 乗算       | 通常の乗算 + 剰余  | \(O((\log n)^2)\)         | 筆算乗算           |
| 乗算       | Karatsuba法 + 剰余 | \(O((\log n)^{1.585})\)   | 高速乗算           |
| 乗算       | FFT法 + 剰余       | \(O(\log n \log \log n)\) | 最速（理論的）     |
| 最大公約数 | Euclid互除法       | \(O((\log n)^2)\)         | 拡張版も同様       |
| 逆元       | 拡張Euclid互除法   | \(O((\log n)^2)\)         | \(a^{-1} \bmod n\) |
| 冪乗算     | バイナリ法         | \(O((\log n)^3)\)         | \(a^k \bmod n\)    |
| 冪乗算     | Montgomery法       | \(O((\log n)^2)\)         | 最適化後           |

### RSA暗号の計算量解析

#### 暗号化の計算量

**アルゴリズム**: \(c = m^e \bmod n\)

**計算量**:
- 指数 \(e\) のビット長: \(O(\log n)\)
- 各ステップの乗算: \(O((\log n)^2)\)
- **総計算量**: \(O((\log n)^3)\)

**最適化**:
- Montgomery乗算を使用: \(O((\log n)^2)\)
- 小さな指数 \(e\) の使用（例: \(e = 65537\)）

#### 復号化の計算量

**アルゴリズム**: \(m = c^d \bmod n\)

**計算量**:
- 指数 \(d\) のビット長: \(O(\log n)\)
- 各ステップの乗算: \(O((\log n)^2)\)
- **総計算量**: \(O((\log n)^3)\)

**CRT復号化による最適化**:
1. \(m_p = c^{d_p} \bmod p\): \(O((\log p)^3) = O((\log n)^3/8)\)
2. \(m_q = c^{d_q} \bmod q\): \(O((\log q)^3) = O((\log n)^3/8)\)
3. 中国剰余定理: \(O((\log n)^2)\)
- **総計算量**: \(O((\log n)^3/4)\)（約4倍高速）

### 多項式時間での実行可能性

**定理**: RSA暗号の暗号化・復号化は、\(\log n\) の多項式時間で実行可能である。

**証明**:
1. **鍵生成**: 
   - 素数生成: \(O((\log n)^4)\)（確率的素数判定）
   - 拡張Euclid互除法: \(O((\log n)^2)\)
   - **総計算量**: \(O((\log n)^4)\)

2. **暗号化**:
   - バイナリ法による冪乗算: \(O((\log n)^3)\)
   - Montgomery法による最適化: \(O((\log n)^2)\)

3. **復号化**:
   - 通常の復号化: \(O((\log n)^3)\)
   - CRT復号化: \(O((\log n)^3/4)\)

すべての演算が \(\log n\) の多項式時間で実行されるため、RSA暗号は効率的に実装可能である。\(\square\)

### 実装上の最適化

#### 1. 小さな公開指数の使用
- \(e = 65537 = 2^{16} + 1\) の使用
- ハミング重みが小さいため、暗号化が高速

#### 2. 中国剰余定理の活用
- 復号化時の計算量を約4倍削減
- 秘密鍵の保存: \((p, q, d_p, d_q, q^{-1} \bmod p)\)

#### 3. Montgomery乗算
- 剰余計算の高速化
- 事前計算による定数時間実装

#### 4. Sliding-Window法
- 連続する0ビットをスキップして効率化
- ウィンドウサイズ \(w\) で \(w\) ビットずつ処理
- 事前計算テーブル: \(\{a, a^3, a^5, \ldots, a^{2^w-1}\}\)

**アルゴリズム**:
```
Input: a, k, n, w (ウィンドウサイズ)
Output: a^k mod n

1. // 事前計算テーブルの構築
2. table[1] = a
3. for i = 3 to 2^w - 1 step 2:
4.     table[i] = table[i-2] * a^2 mod n
5. 
6. result = 1
7. i = bit_length(k) - 1
8. while i >= 0:
9.     if k[i] == 0:
10.         result = result^2 mod n
11.         i -= 1
12.     else:
13.         // wビットのウィンドウを読み取り
14.         window = 0
15.         for j = 0 to min(w-1, i):
16.             window = 2*window + k[i-j]
17.         if window == 0:
18.             result = result^2 mod n
19.             i -= 1
20.         else:
21.             // 奇数ウィンドウ値の処理
22.             for j = 0 to w:
23.                 result = result^2 mod n
24.             result = result * table[window] mod n
25.             i -= w
26. 
27. return result
```

**計算量**: \(O(\log k)\) 回の乗算（通常のバイナリ法より約25%高速）

**利点**:
- 連続する0ビットを効率的にスキップ
- メモリ使用量と計算量の最適なバランス
- 実装が比較的簡単

### 素数生成と素数判定アルゴリズム

RSA暗号の鍵生成において、大きな素数 \(p, q\) の生成は重要な要素である。以下に、多項式時間で実行可能な素数判定アルゴリズムを紹介する。

#### Fermat素数判定法

**原理**: フェルマーの小定理に基づく確率的素数判定法

**アルゴリズム**:
```
Input: n, k (試行回数)
Output: "probably prime" or "composite"

1. for i = 1 to k:
2.     a = random integer in [2, n-1]
3.     if gcd(a, n) != 1:
4.         return "composite"
5.     if a^(n-1) mod n != 1:
6.         return "composite"
7. return "probably prime"
```

**計算量**: \(O(k \cdot (\log n)^3)\)

**特徴**:
- 高速だが、カーマイケル数（擬素数）に対して誤判定する
- カーマイケル数は無限に存在する
- 実用的にはMiller-Rabin法が推奨される

**誤判定の確率**: カーマイケル数に対しては100%誤判定

#### Miller-Rabin素数判定法

**原理**: フェルマーの小定理の逆をより厳密に検証する確率的素数判定法

**補題**: 奇素数 \(p\) に対して、\(p-1 = 2^s \cdot d\)（\(d\) は奇数）と分解するとき、任意の \(a\) に対して以下のいずれかが成り立つ：
1. \(a^d \equiv 1 \pmod{p}\)
2. ある \(r \in \{0, 1, \ldots, s-1\}\) に対して \(a^{2^r \cdot d} \equiv -1 \pmod{p}\)

**アルゴリズム**:
```
Input: n, k (試行回数)
Output: "probably prime" or "composite"

1. if n == 2: return "prime"
2. if n < 2 or n % 2 == 0: return "composite"
3. 
4. // n-1 = 2^s * d の形に分解
5. s = 0, d = n - 1
6. while d % 2 == 0:
7.     s += 1
8.     d //= 2
9. 
10. for i = 1 to k:
11.     a = random integer in [2, n-1]
12.     x = a^d mod n
13.     if x == 1 or x == n-1:
14.         continue
15.     for r = 1 to s-1:
16.         x = x^2 mod n
17.         if x == n-1:
18.             break
19.         if x == 1:
20.             return "composite"
21.     else:
22.         return "composite"
23. return "probably prime"
```

**計算量**: \(O(k \cdot (\log n)^3)\)

**特徴**:
- カーマイケル数に対しても高い精度
- 実用的な素数判定の標準
- 誤判定確率は \(4^{-k}\) 以下

**誤判定の確率**: 任意の合成数に対して、ランダムな基底 \(a\) で誤判定する確率は \(1/4\) 以下

#### AKS素数判定法（Agrawal-Kayal-Saxena）

**原理**: 多項式恒等式に基づく決定的素数判定法

**定理**: 整数 \(n > 1\) が素数である必要十分条件は、ある \(r\) に対して以下が成り立つこと：
\[(X + a)^n \equiv X^n + a \pmod{n, X^r - 1}\]
ただし、\(a\) は \(n\) と互いに素な整数。

**アルゴリズム**:
```
Input: n
Output: "prime" or "composite"

1. if n is a perfect power: return "composite"
2. 
3. // 適切な r を見つける
4. r = 2
5. while r < n:
6.     if gcd(n, r) != 1: return "composite"
7.     if r is prime:
8.         q = largest prime factor of r-1
9.         if q >= 4*sqrt(r)*log(n) and n^((r-1)/q) mod r != 1:
10.             break
11.     r += 1
12. 
13. // 多項式恒等式の検証
14. for a = 1 to floor(2*sqrt(r)*log(n)):
15.     if gcd(a, n) > 1: return "composite"
16.     if (X + a)^n mod (n, X^r - 1) != X^n + a:
17.         return "composite"
18. 
19. return "prime"
```

**計算量**: \(O((\log n)^{12})\)（改良版では \(O((\log n)^6)\)）

**特徴**:
- 決定的アルゴリズム（誤判定なし）
- GRH（一般化リーマン予想）を仮定しない
- 理論的に重要だが、実用的には遅い

**理論的意義**:
- 素数判定がP問題であることを証明
- 多項式時間での決定的素数判定の存在を示す

### 素数生成の実装

**確率的素数生成**:
```
Input: bit_length
Output: probable prime p

1. while True:
2.     p = random odd integer of bit_length bits
3.     if Miller-Rabin(p, k=40):  // 40回の試行
4.         return p
```

**計算量**: 平均 \(O((\log n)^4)\)（素数定理より、約 \(\log n\) 回の試行が必要）

**安全性**:
- 2048ビットRSAでは、\(k=40\) 回のMiller-Rabin試行で十分
- 誤判定確率は \(4^{-40} \approx 2^{-80}\) 以下

### 中国剰余定理を用いた高速化（RSA-CRT）

実際の実装では、中国剰余定理を用いて復号化を高速化する。この手法は**RSA-CRT**（RSA with Chinese Remainder Theorem）とも呼ばれる。

**CRT復号化**:
1. \(m_p = c^{d_p} \pmod{p}\) を計算（\(d_p = d \pmod{p-1}\)）
2. \(m_q = c^{d_q} \pmod{q}\) を計算（\(d_q = d \pmod{q-1}\)）
3. 中国剰余定理を用いて \(m \pmod{n}\) を計算

この方法により、指数の大きさが約半分になり、計算量が大幅に削減される。

**詳細なアルゴリズム**:
```
Input: c, p, q, d_p, d_q, q_inv
Output: m = c^d mod n

1. m_p = c^(d_p) mod p
2. m_q = c^(d_q) mod q
3. h = (q_inv * (m_p - m_q)) mod p
4. m = m_q + h * q
5. return m
```

**計算量の比較**:
- 通常の復号化: \(O((\log n)^3)\)
- CRT復号化: \(O((\log p)^3 + (\log q)^3 + (\log n)^2) = O((\log n)^3/4)\)

**利点**:
- 約4倍の高速化
- 並列化可能（\(m_p\) と \(m_q\) の計算を並列実行）
- メモリ効率が良い

## RSA暗号の安全性

### 素因数分解の困難性

RSA暗号の安全性は、大きな合成数の素因数分解の困難性に基づいている。以下に主要な素因数分解アルゴリズムを紹介し、安全性を評価する。

#### 試し切り法（Trial Division）

**原理**: 2から \(\sqrt{n}\) までの全ての素数で割り切れるか試す

**アルゴリズム**:
```
Input: n
Output: a factor of n or "prime"

1. if n % 2 == 0: return 2
2. for d = 3 to floor(sqrt(n)) step 2:
3.     if n % d == 0:
4.         return d
5. return "prime"
```

**計算量**: \(O(\sqrt{n}) = O(2^{b/2})\)（\(b\) はビット長）

**特徴**: 
- 最も基本的な方法
- 小さな素因数を見つけるのに有効
- 大きな数に対しては非現実的

#### Pollard ρ法

**原理**: フロイドの循環検出アルゴリズムを用いた確率的素因数分解法

**ρと呼ばれる理由**: このアルゴリズムでは、関数 \(f(x) = x^2 + 1 \pmod{n}\) を繰り返し適用することで、数列 \(x_0, x_1, x_2, \ldots\) を生成する。この数列は最終的に循環に陥り、その軌跡がギリシャ文字のρ（ロー）の形に似ていることから「ρ法」と呼ばれる。

**循環の発生**: 
- 有限集合 \(\mathbb{Z}_n\) 上での関数の繰り返し適用により、必ず循環が発生する
- 循環の長さは平均的に \(O(\sqrt{n})\) 程度
- フロイドの循環検出により、循環の開始点を効率的に発見

**アルゴリズム**:
```
Input: n
Output: a factor of n or "failure"

1. x = y = 2
2. d = 1
3. while d == 1:
4.     x = f(x) mod n  // f(x) = x^2 + 1
5.     y = f(f(y)) mod n
6.     d = gcd(|x - y|, n)
7. if d == n:
8.     return "failure"
9. else:
10.     return d
```

**計算量**: \(O(\sqrt{p})\)（\(p\) は最小素因数）

**特徴**:
- 小さな素因数を効率的に発見
- 確率的アルゴリズム
- 実装が比較的簡単

#### Pollard p-1法

**原理**: フェルマーの小定理を利用した素因数分解法

**アルゴリズム**:
```
Input: n, B (bound)
Output: a factor of n or "failure"

1. a = 2
2. for i = 2 to B:
3.     a = a^i mod n
4. d = gcd(a - 1, n)
5. if 1 < d < n:
6.     return d
7. else:
8.     return "failure"
```

**計算量**: \(O(B \log B \log n)\)

**特徴**:
- \(p-1\) が小さな素因数のみからなる場合に有効
- 特定の構造を持つ素数に対して脆弱
- 実装が簡単

#### ランダム2乗法（Random Squares Method）

**原理**: 平方剰余の性質を利用した素因数分解法

**アルゴリズム**:
```
Input: n
Output: a factor of n or "failure"

1. factor_base = [small primes]
2. relations = []
3. while not enough relations:
4.     x = random integer near sqrt(n)
5.     y = x^2 mod n
6.     if y factors over factor_base:
7.         relations.append((x, y, factors))
8. 
9. // 線形代数で解を求める
10. solve linear system over GF(2)
11. return factor
```

**計算量**: \(O(e^{\sqrt{\log n \log \log n}})\)

**特徴**:
- 準指数時間アルゴリズム
- 実装が複雑
- 中程度のサイズの数に有効

#### 数体篩法（Number Field Sieve, NFS）

**原理**: 代数体の性質を利用した最強の素因数分解アルゴリズム

**アルゴリズム**:
```
Input: n
Output: a factor of n

1. // 多項式選択
2. choose irreducible polynomial f(x) with root m mod n
3. 
4. // 篩処理
5. factor_base = [small primes and ideals]
6. relations = []
7. for a, b in sieve region:
8.     if N(a - b*m) and N(a - b*alpha) are smooth:
9.         relations.append((a, b, factorizations))
10. 
11. // 線形代数
12. solve large sparse linear system
13. 
14. // 平方根計算
15. compute square root in number field
16. return factor
```

**計算量**: \(O(e^{(\frac{64}{9})^{1/3} (\log n)^{1/3} (\log \log n)^{2/3}})\)

**特徴**:
- 現在最強の素因数分解アルゴリズム
- 実装が非常に複雑
- 大きな数（512ビット以上）に有効

### 安全性評価と推奨鍵長

#### RSAチャレンジ問題の解読記録

| ビット長  | 解読年 | 使用アルゴリズム | 計算時間 |
| --------- | ------ | ---------------- | -------- |
| 512ビット | 1999年 | 数体篩法         | 7ヶ月    |
| 576ビット | 2003年 | 数体篩法         | 2年      |
| 640ビット | 2005年 | 数体篩法         | 5ヶ月    |
| 768ビット | 2009年 | 数体篩法         | 2年      |

#### NIST推奨鍵長

**2023年現在の推奨**:
- **2030年まで**: 2048ビット以上
- **2030年以降**: 3072ビット以上
- **長期保存**: 4096ビット以上

**根拠**:
- 数体篩法の計算量に基づく評価
- 量子計算機の脅威を考慮
- 実装コストとセキュリティのバランス

#### 計算量の比較

| アルゴリズム  | 計算量                                                             | 適用範囲     |
| ------------- | ------------------------------------------------------------------ | ------------ |
| 試し切り法    | \(O(2^{b/2})\)                                                     | 小さな数     |
| Pollard ρ法   | \(O(\sqrt{p})\)                                                    | 小さな素因数 |
| Pollard p-1法 | \(O(B \log B \log n)\)                                             | 特殊な構造   |
| ランダム2乗法 | \(O(e^{\sqrt{\log n \log \log n}})\)                               | 中程度の数   |
| 数体篩法      | \(O(e^{(\frac{64}{9})^{1/3} (\log n)^{1/3} (\log \log n)^{2/3}})\) | 大きな数     |

### 量子計算機の脅威

#### Shorのアルゴリズム

**原理**: 量子計算機を用いた素因数分解アルゴリズム

**計算量**: \(O((\log n)^3)\)

**脅威**:
- 多項式時間での素因数分解
- RSA暗号の完全な破綻
- 現在の実装では数千量子ビットが必要

#### 対策

**短期的**:
- 鍵長の増加（4096ビット以上）
- ハイブリッド暗号の使用

**長期的**:
- 後量子暗号（PQC）への移行
- 格子暗号、多変数暗号等の研究

### 単純なRSA暗号の一方向性

**RSA問題**: 与えられた \(n, e, c\) に対して、\(c \equiv m^e \pmod{n}\) を満たす \(m\) を求める問題。

**仮定**: RSA問題は困難である（RSA仮定）

**注意**: 単純なRSA暗号は以下の理由で実用的ではない：
- 決定性暗号化（同じ平文は同じ暗号文）
- 小さな平文に対する攻撃が可能
- 適応的選択暗号文攻撃（CCA2）に対して脆弱

### 安全性評価と攻撃手法の数学的分析

#### gcd(m, n) > 1 の確率

**定理**: ビット長 \(\lambda\) の素数 \(p, q\) と公開鍵 \(n = pq\) のRSA暗号において、ランダムに選ばれた平文 \(m \in \mathbb{Z}_n\) が \(\gcd(m, n) > 1\) となる確率は \(\frac{1}{2^{\lambda-3}}\) 以下である。

**証明**: 

1. **基本設定**: \(n = pq\) で、\(p, q\) は \(\lambda\) ビットの素数とする。

2. **\(\gcd(m, n) > 1\) となる \(m\) の個数**:
   - \(m\) が \(p\) の倍数: \(q\) 個（\(0, p, 2p, \ldots, (q-1)p\)）
   - \(m\) が \(q\) の倍数: \(p\) 個（\(0, q, 2q, \ldots, (p-1)q\)）
   - \(m = 0\) は重複しているので、総数は \(p + q - 1\)

3. **確率の計算**:
   \[\Pr[\gcd(m, n) > 1] = \frac{p + q - 1}{n} = \frac{p + q - 1}{pq} = \frac{1}{q} + \frac{1}{p} - \frac{1}{pq}\]

4. **上界の導出**:
   - \(p, q \geq 2^\lambda\)（\(\lambda\) ビットの素数）
   - \(pq \geq 2^{2\lambda-2}\)
   - したがって：
     \[\frac{1}{p} + \frac{1}{q} - \frac{1}{pq} \leq \frac{1}{2^{\lambda-2}} + \frac{1}{2^{\lambda-2}} = \frac{2}{2^{\lambda-2}} = \frac{1}{2^{\lambda-3}}\]

5. **より厳密な上界**:
   - 実際には、素数定理により \(p, q\) は平均的に \(2^{\lambda}\) に近い
   - より正確には \(\frac{1}{2^{\lambda-3}}\) 以下であることが示せる

**具体例**:
- **1024ビット素数**: 確率は \(\frac{1}{2^{1021}}\) 以下
- **2048ビットRSA**: 確率は \(\frac{1}{2^{2045}}\) 以下

**結論**: 実用的には完全に無視できる確率である。この確率は、宇宙の原子の数（約 \(2^{265}\)）よりもはるかに小さい。

#### 最暗号化攻撃（Blinding Attack）

**攻撃手法**: 攻撃者が暗号化オラクルに \(m \cdot r^e \pmod{n}\) を送信し、結果を \(r^{-1}\) で割ることで \(m^e \pmod{n}\) を得る。

**対策**: ランダムパディング（OAEP）の使用

**数学的分析**:
- 攻撃成功確率: パディングなしの場合100%
- パディングありの場合: ランダムオラクルモデルで無視できる確率

#### 低暗号化べき攻撃（Low Exponent Attack）

**攻撃手法**: 小さな公開指数 \(e\) に対して、\(m^e < n\) の場合、\(m = \sqrt[e]{c}\) で平文を復元。

**条件**: \(m < n^{1/e}\)

**数学的分析**:
- 攻撃可能な平文の割合: \(\frac{n^{1/e}}{n} = n^{1/e - 1}\)
- \(e = 3\) の場合: 約 \(n^{-2/3}\) の確率
- 対策: 適切なパディングの使用

#### 低秘密鍵べき攻撃（Wiener's Attack）

**攻撃手法**: 秘密鍵 \(d\) が小さすぎる場合、連分数展開により \(d\) を復元。

**条件**: \(d < \frac{1}{3}n^{1/4}\)

**数学的分析**:
- 連分数展開の計算量: \(O((\log n)^2)\)
- 攻撃可能な鍵の割合: 約 \(n^{-1/4}\)
- 対策: \(d > n^{1/4}\) の確保

#### サイドチャネル攻撃（電力解析攻撃）

**単純電力解析（SPA）**:
- **攻撃手法**: 電力消費パターンから秘密鍵を推定
- **脆弱性**: バイナリ法の実装で0ビットと1ビットの電力差
- **対策**: 定数時間実装、ダミー演算

**差分電力解析（DPA）**:
- **攻撃手法**: 統計的手法で電力消費の相関を分析
- **数学的モデル**: 電力消費 \(P(t) = \alpha \cdot H(t) + \beta + \epsilon(t)\)
  - \(H(t)\): ハミング重み
  - \(\alpha, \beta\): 定数
  - \(\epsilon(t)\): ノイズ

**対策**:
- マスキング技術
- ランダム化
- 定数時間実装

#### 最下位ビットに対する安全性

**定理**: RSA暗号の最下位ビット（LSB）は、RSA問題と同等に困難である。

**定理（詳細版）**: 暗号文から平文の最下位ビットを時間 \(t\) で求めるオラクル \(O_L\) が存在する場合、\(O_L\) に対する \(O(\log n)\) 回のクエリ、時間 \(O((\log n)t + (\log n)^3)\) でRSA暗号の一方向性を解くことができる。

**証明**: 

1. **設定**: 
   - 暗号文 \(c = m^e \pmod{n}\)
   - 平文 \(m \in [0, n-1]\)
   - LSBオラクル \(O_L(c) = \text{LSB}(m)\)

2. **二分探索アルゴリズム**:
   ```
   Input: c, n, e, O_L
   Output: m
   
   1. low = 0, high = n-1
   2. for i = 1 to log_2(n):
   3.     mid = (low + high) / 2
   4.     c' = c * (2^i)^e mod n
   5.     lsb = O_L(c')
   6.     if lsb == 0:
   7.         high = mid
   8.     else:
   9.         low = mid + 1
   10. return low
   ```

3. **アルゴリズムの正当性**:
   - \(c' = c \cdot (2^i)^e \pmod{n} = (m \cdot 2^i)^e \pmod{n}\)
   - \(O_L(c') = \text{LSB}(m \cdot 2^i \pmod{n})\)
   - \(m \cdot 2^i \pmod{n}\) のLSBは、\(m\) が区間 \([0, \frac{n}{2^i})\) に含まれるかどうかを示す

4. **計算量の分析**:
   - **オラクル呼び出し回数**: \(O(\log n)\) 回
   - **各ステップの計算**:
     - 冪乗算: \(O((\log n)^3)\)
     - オラクル呼び出し: \(O(t)\)
   - **総計算量**: \(O((\log n)t + (\log n)^3)\)

5. **詳細な数学的証明**:
   
   **補題**: \(m \cdot 2^i \pmod{n}\) のLSBは、\(m\) が区間 \([0, \frac{n}{2^i})\) に含まれるかどうかを示す。
   
   **証明**:
   - \(m \cdot 2^i = q \cdot n + r\)（\(0 \leq r < n\)）
   - \(r = m \cdot 2^i \pmod{n}\)
   - \(m < \frac{n}{2^i}\) のとき、\(r = m \cdot 2^i\) でLSBは0
   - \(m \geq \frac{n}{2^i}\) のとき、\(r\) のLSBは1

6. **二分探索の収束**:
   - 初期区間: \([0, n-1]\)
   - 各ステップで区間を半分に縮小
   - \(\log_2(n)\) ステップで正確な値に収束

**結論**: LSBの安全性はRSA問題の困難性と等価である。LSBオラクルが存在すれば、多項式時間でRSA暗号を解読できる。

#### 適応的選択暗号文攻撃（CCA2）に対する脆弱性

**攻撃手法**: 
1. 攻撃者が暗号文 \(c\) を入手
2. 復号オラクルに \(c' = c \cdot r^e \pmod{n}\) を送信
3. 結果を \(r^{-1}\) で割って元の平文を復元

**数学的分析**:
- 攻撃成功確率: 100%（パディングなし）
- 計算量: \(O((\log n)^3)\)（1回の復号化）

**対策**: 
- OAEPなどの適切なパディング
- 整合性チェックの実装

#### 安全性の総合評価

**理論的安全性**:
- **一方向性**: RSA問題の困難性に基づく
- **部分情報**: LSBの安全性が証明されている
- **適応的攻撃**: 適切なパディングで対抗可能

**実装上の安全性**:
- **サイドチャネル**: 定数時間実装で対策
- **タイミング攻撃**: ランダム化で対策
- **電力解析**: マスキング技術で対策

**推奨事項**:
1. 2048ビット以上の鍵長
2. OAEPパディングの使用
3. 定数時間実装
4. 適切な乱数生成

### 乱数パディング方式

#### PKCS#1 v1.5

**暗号化**: 平文 \(m\) に対して、以下の形式でパディングする：

```
0x00 || 0x02 || 乱数 || 0x00 || m
```

**問題点**: Bleichenbacher攻撃（パディングオラクル攻撃）に対して脆弱

#### OAEP（Optimal Asymmetric Encryption Padding）

**構成**: 2つのハッシュ関数 \(G, H\) を用いる

**暗号化**:
1. \(r \overset{\$}{\leftarrow} \{0,1\}^{k_0}\)
2. \(s = m \oplus G(r)\)
3. \(t = r \oplus H(s)\)
4. \(x = s \parallel t\)
5. \(c = x^e \pmod{n}\)

**復号化**:
1. \(x = c^d \pmod{n}\)
2. \(s \parallel t = x\)（適切な長さに分割）
3. \(r = t \oplus H(s)\)
4. \(m = s \oplus G(r)\)

### パディングオラクル攻撃

**Bleichenbacher攻撃**: PKCS#1 v1.5に対する適応的選択暗号文攻撃

**攻撃手法**:
1. 攻撃者は暗号文 \(c\) を入手
2. 復号オラクルに様々な \(c'\) を送信
3. パディングが正しいかどうかの情報を収集
4. この情報を用いて元の平文を復元

**対策**: OAEPなどの適切なパディング方式の使用

### IND-CCA2安全性

**定理**: RSA-OAEPは、ランダムオラクルモデルにおいてIND-CCA2安全である。

**証明スケッチ**: `docs/004_asymmetric/security_proofs.md` で紹介された定理を適用する。

RSA-OAEPは以下の形式で暗号文を構成する：

\[c = (s \parallel t)^e \pmod{n}\]

ここで：
- \(s = m \oplus G(r)\)
- \(t = r \oplus H(s)\)

この構成は、`security_proofs.md` の定理で扱われた「剰余環の元3個で構成されるパターン」に該当する：

1. \(c_1 = F(r)\): RSA関数 \(F(r) = r^e \pmod{n}\)
2. \(c_2 = m \oplus G(r)\): メッセージ部分
3. \(c_3 = H(r, m)\): 整合性チェック（\(H(s)\) として実装）

### ランダムオラクルの工夫

**問題**: 実際の実装では、理想的なランダムオラクルは存在しない。

**解決策**:
1. **ハッシュ関数の使用**: SHA-256などの暗号学的ハッシュ関数を使用
2. **KDFの使用**: HKDFなどの鍵導出関数を使用
3. **標準化**: RFC 8017（PKCS#1 v2.2）でOAEPが標準化

**実装例**:
```python
def rsa_oaep_encrypt(pk, m):
    # G, H を SHA-256 で実装
    r = random_bytes(k0)
    s = xor(m, hash_g(r))
    t = xor(r, hash_h(s))
    x = s || t
    return pow(x, e, n)

def rsa_oaep_decrypt(sk, c):
    x = pow(c, d, n)
    s, t = split(x)
    r = xor(t, hash_h(s))
    m = xor(s, hash_g(r))
    return m
```

## RSA-OAEP

### 詳細な仕様

**パラメータ**:
- \(k\): セキュリティパラメータ
- \(k_0\): 乱数長（通常 \(k_0 = 256\)）
- \(k_1\): パディング長（通常 \(k_1 = 256\)）
- \(n\): RSA modulus（\(|n| = k\)）

**ハッシュ関数**:
- \(G: \{0,1\}^{k_0} \to \{0,1\}^{k_1}\)
- \(H: \{0,1\}^{k_1} \to \{0,1\}^{k_0}\)

### 安全性証明の概要

**還元**: RSA-OAEPのIND-CCA2安全性は、RSA問題の困難性に還元される。

**証明の流れ**:
1. 敵対者がRSA-OAEPを破る
2. ランダムオラクルへの問い合わせを監視
3. 特定の問い合わせが発生した時点でRSA問題を解く
4. この還元により、RSA-OAEPの安全性がRSA仮定に基づくことが示される

### 実装上の注意点

**定数時間実装**: タイミング攻撃を防ぐため、定数時間での実装が必要

**エラー処理**: パディングエラーが発生した場合の適切な処理

**鍵サイズ**: 現在では2048ビット以上が推奨される

### 標準化

**RFC 8017**: PKCS#1 v2.2でRSA-OAEPが標準化されている

**パラメータ**:
- ハッシュ関数: SHA-256
- MGF: MGF1 with SHA-256
- ラベル: 空文字列（通常）

## まとめ

RSA暗号は、数学的基礎に基づく堅牢な公開鍵暗号方式である。単純なRSA暗号は実用的ではないが、OAEPなどの適切なパディング方式と組み合わせることで、IND-CCA2安全性を達成できる。

重要なポイント：
1. **数学的基礎**: 剰余環、中国剰余定理、オイラーの定理
2. **正当性**: 数学的証明による保証
3. **安全性**: パディング方式の重要性
4. **実装**: 標準化された方式の使用

RSA暗号は、現代の暗号学において重要な役割を果たしており、適切に実装されれば高い安全性を提供する。
